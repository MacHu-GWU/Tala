#基于Sqlite3的单元搜索引擎
------

##什么叫单元搜索(Field Search)

我们拿IMDB(International Movie DataBase)为例。 每一部电影应可能具有但不限于如下的元素:

1. **movie_id**, 是数字或者字符串。 每一部电影具有唯一的movie_id
2. **title**, 字符串。 每一部电影的名称
3. **director**, 字符串。 电影主导演名字 
4. **cast**, 字符串的集合。 电影参演明星的名字的集合
5. **release_date**, 日期。 电影首映的日期
6. **release_year**, 年份, 数字。 电影首映的年份
7. **genres**, 字符串的集合。 电影的类别, 例如: action, adventure, drama...

我们在搜索电影时候, 很可能希望通过**电影名称**模糊搜索, 或者根据**演员阵容**搜索有某些影星出演的电影, 又或是根据电影的**类别**搜索某一类或者某几类电影, 再也许最后加上**上映时间**的限制, 筛选出在某一定时间区间内上映的电影。 我们对这一类文档搜索, 主要是根据文档的各个单元的进行逻辑与, 或, 非的排列组合进行筛选。 这就叫**单元搜索**。

##单元搜索中的抽象定义

###文档(Document)
一条数据被称作一个文档。 例如之前提到的一部电影的所有数据就叫一个文档。

对应于关系型数据库中每一行(row)的概念。 也对应于MongoDB中的[Document](http://www.w3cschool.cc/mongodb/mongodb-databases-documents-collections.html "MongoDB Document")概念。

每一条文档对应数据库中的一行。每一列对应文档的一个元素, 其中有些是能够被搜索到的, 有些是不能被搜索到的。

###单元(Field)
文档中不同的文档元素被称作单元。 例如前面提到的movie_id, title, cast这都是单元。

对应着关系型数据库中列(column)的概念。 也对应于NonSql中的Key-Value对的概念。

其中有些单元是能被搜索到的, 有些则是不能被搜索到的。 虽然有些单元不能被搜索到, 但是在调用该文档时会随着其他元素一同被显示出来。

###可搜索数据类型(Searchable Dtype)
在数据库中的每一列都有一个数据类型, 例如Interger, Real, Text。 但这些是数据库中的数据类型。 可搜索数据类型定义了文档的每一个单元能以何种方式被搜索到。 例如同样是TEXT, 我们定义movie_id必须**完全匹配**上才能被搜索到; 而title可以被**部分匹配**搜索到。 每一个单元都需要绑定一种可搜索数据类型。 对于不可被搜索到的单元, 我们可以绑定"不可搜索数据类型"(其本身也是一种Searchable Dtype)

###轮廓(Schema)
在**轮廓**中, 我们定义了文档有多少个单元, 每一个单元绑定了何种可搜索数据类型。

    为了方便说明, 以下提及上面的定义时, 都使用英文名。

##单元搜索中的算法

为了方便还是以IMDB movie为例子进行解说。 

- 对于movie_id我们使用完全匹配, 对应于Sql语句中的 where movie_id = "#movie_id"
- 对于title, 我们使用部分匹配, 对应于Sql语句中的 where title LIKE pattern
- 对于时间, 日期和其他数值型单元, 我们可以用Sql中的 where release_date >= "2010-01-01"

而对于集合型单元, 为了避免每次对整表进行扫描, 我们针对集合型单元制作了倒排索引([Invert Index](http://en.wikipedia.org/wiki/Inverted_index "Invert Index")), 并为每一个集合型单元创建一个新表用于保存倒排索引。

所以对于用户的搜索请求, 其他单元可以通过Sql Select语句进行筛选, 而对于集合型单元可以通过Invert Index进行查询, 然后求结果的交集即可。

##定义单元搜索引擎

每一个文档